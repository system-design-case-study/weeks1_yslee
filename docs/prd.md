# [PRD] 근처 맛집 찾기 서비스 (Proximity Service)

> **Reference:** 『가상 면접 사례로 배우는 대규모 시스템 설계 기초 2』 - 1장
> **목적:** 대규모 위치 기반 시스템의 핵심 개념(Geohash, Read/Write 분리, 캐싱 전략)을 직접 구현하며 학습한다.

## 1. 프로젝트 개요

사용자의 현재 위치(위도, 경도)를 기반으로 특정 반경 내에 있는 사업장(POI) 정보를 빠르고 정확하게 제공하는 시스템을 구축한다.

### 1.1 범위 (Scope)

**포함:**
* 위치 기반 주변 검색 (Geohash 인덱싱)
* 사업장 CRUD (등록/조회/수정/삭제)
* Redis 기반 검색 인덱스 캐싱
* 배치 동기화 (DB → Redis)

**제외:**
* 사용자 인증/회원 시스템 (API Key 기반 간이 인증만 적용)
* 리뷰/평점 시스템
* 실시간 영업 여부 표시
* 즐겨찾기/북마크
* 결제/예약 기능

### 1.2 구현 우선순위

| 단계 | 기능 | 학습 포인트 |
|------|------|------------|
| Phase 1 | 주변 검색 API + Geohash 인덱싱 | Geohash 알고리즘, Redis GEO, 경계값 문제 |
| Phase 2 | 사업장 CRUD API | REST 설계, DB 스키마, Read/Write 분리 |
| Phase 3 | 앱 레벨 동기화 + 복구용 배치 | 데이터 정합성, 장애 복구 전략 |

---

## 2. 사용자 시나리오

### 시나리오 1: 주변 맛집 검색 (핵심)

점심시간에 사용자가 현재 위치 근처의 음식점을 찾는다.

* **Given** 사용자가 위치 정보를 제공한 상태에서
* **When** 반경 1km 이내 음식점을 검색하면
* **Then** 거리순으로 정렬된 음식점 목록(이름, 주소, 거리, 카테고리)을 반환한다.

### 시나리오 2: 사업장 상세 조회

검색 결과에서 특정 가게를 선택하여 상세 정보를 확인한다.

* **Given** 검색 결과 목록에서 가게를 선택하면
* **When** 상세 조회 API를 호출하면
* **Then** 이름, 주소, 전화번호, 영업시간, 카테고리 등 전체 정보를 반환한다.

### 시나리오 3: 사업장 등록

사업자가 자신의 가게를 시스템에 등록한다.

* **Given** 사업장 정보(이름, 주소, 위경도, 카테고리)를 입력하면
* **When** 등록 API를 호출하면
* **Then** 사업장이 DB에 저장되고, 다음 배치 동기화 시 검색 인덱스에 반영된다.

### 예외 케이스

* 검색 반경 내 결과가 0건 → 빈 배열과 함께 반경 확대 안내 메시지 반환
* 잘못된 좌표값 (범위 초과) → 400 Bad Request + 유효 범위 안내
* 존재하지 않는 사업장 ID 조회 → 404 Not Found

---

## 3. 목표 수치 및 제약 조건 (Capacity Estimation)

대규모 시스템 설계를 위해 아래의 수치를 시스템의 기본 제약 조건으로 설정한다.

* **POI(Point of Interest) 데이터:** 전 세계 약 **2억 개**.
* **일일 활성 사용자(DAU):** 1억 명.
* **검색 트래픽:** 일일 약 5억 건의 검색 요청.
* **평균 QPS:** 약 5,800 QPS.
* **최대(Peak) QPS:** 약 11,600 QPS.
* **성능 목표:** 검색 결과 응답 지연 시간(Latency)은 **100ms 이내**.
* **데이터 갱신:** Read-heavy 시스템. 사업장 등록/삭제 시 즉시 Redis 반영, 상세 정보 변경은 MySQL만 업데이트.

> **학습 노트:** QPS 계산 과정
> DAU 1억 × 1일 5회 검색 = 5억 건/일
> 5억 / 86,400초 ≈ 5,800 QPS (평균)
> Peak는 평균의 2배로 가정 ≈ 11,600 QPS

---

## 4. 요구사항 (Requirements)

### 4.1 기능적 요구사항

* **주변 검색:** 사용자 위치(lat, lng)와 검색 반경(radius)을 기반으로 POI 목록 반환.
* **사업장 관리:** 신규 사업장 등록(Create), 정보 수정(Update), 삭제(Delete).
* **상세 정보 조회:** 특정 사업장의 상세 프로필(이름, 주소, 메뉴 등) 조회.

### 4.2 비기능적 요구사항

* **저지연(Low Latency):** 위치 기반 검색의 특성상 매우 빠른 응답 필요.
* **가용성(Availability):** 시스템 일부 장애 시에도 검색 서비스 유지.
* **확장성(Scalability):** 트래픽 증가 시 서버 및 DB의 수평적 확장 가능 여부.

---

## 5. API 명세 (API Specification)

### 5.1 주변 검색 API (Search Service)

* **Endpoint:** `GET /v1/search/nearby`
* **Description:** 특정 반경 내의 사업장 목록을 거리순으로 반환한다.

**Request Parameters:**

| 파라미터 | 타입 | 필수 | 설명 |
|---------|------|------|------|
| latitude | decimal | Y | 현재 위도 (-90 ~ 90) |
| longitude | decimal | Y | 현재 경도 (-180 ~ 180) |
| radius | int | N | 검색 반경, 단위 m (기본값 5000, 최대 20000) |

**Response:**

```json
{
  "total": 25,
  "businesses": [
    {
      "id": "biz_abc123",
      "name": "맛있는 식당",
      "address": "서울시 강남구 테헤란로 123",
      "latitude": 37.5012,
      "longitude": 127.0396,
      "distance_m": 320,
      "category": "korean_food"
    }
  ]
}
```

> 페이지네이션은 스터디 범위에서 제외한다. 반경 검색 특성상 결과 수가 제한적이며, 필요 시 `limit/offset` 파라미터로 확장 가능하다.

### 5.2 사업장 관리 API (Business Service)

* `GET /v1/businesses/:id` — 특정 가게 상세 정보 조회
* `POST /v1/businesses` — 신규 가게 등록
* `PUT /v1/businesses/:id` — 가게 정보 수정
* `DELETE /v1/businesses/:id` — 가게 삭제

---

## 6. 데이터 모델

### 6.1 Business (사업장)

| 필드 | 타입 | 설명 |
|------|------|------|
| id | string (UUID) | 고유 식별자 |
| name | string | 사업장 이름 |
| address | string | 주소 |
| latitude | decimal | 위도 |
| longitude | decimal | 경도 |
| category | string | 카테고리 (korean_food, cafe, convenience 등) |
| phone | string | 전화번호 |
| hours | string | 영업시간 (예: "09:00-22:00") |
| created_at | datetime | 등록일시 |
| updated_at | datetime | 수정일시 |

### 6.2 Redis 검색 인덱스

| 키 | 자료구조 | 저장 데이터 |
|----|---------|------------|
| `geo:businesses` | GEO (Sorted Set) | member=business_id, 위경도 좌표 |

> Redis에는 검색에 필요한 최소한의 데이터(ID + 좌표)만 저장한다. 상세 정보는 MySQL에서 조회한다.

---

## 7. 아키텍처 및 설계 결정 기록 (Architecture Decision Records)

> 스터디 목적으로 각 아키텍처 선택의 배경과 트레이드오프를 기록한다.

### 의사결정 흐름

아키텍처를 처음부터 한꺼번에 정한 것이 아니라, 요구사항을 분석하면서 자연스럽게 결정이 이어졌다.

```
① 사업장 CRUD 기능 검토
   → 사업장 데이터는 하루에 한 번만 갱신하면 충분하다 (Read-heavy)

② "하루 1회 갱신이면 캐시로 충분하겠다"
   → 인메모리 저장소 Redis를 떠올림
   → 메모리에 올라가는 총 데이터 양(약 20GB)은 AI를 통해 추정하여 단일 노드로 수용 가능함을 확인

③ Redis로 위치 검색을 어떻게 할까?
   → Redis가 GEO 명령(GEOADD, GEORADIUS)을 네이티브 지원하는 것을 발견
   → 내부적으로 Geohash 기반으로 동작

④ "별도 공간 인덱스를 구현할 필요 없이 Redis GEO를 그대로 쓰자"
   → Geohash 알고리즘 선택 확정

⑤ 나머지 결정은 이 흐름의 연장선
   → 원본 데이터는 MySQL에 보관 (영속성)
   → 검색 인덱스는 Redis에 분리 (성능)
   → 동기화는? Redis에 좌표+ID만 있으니, 좌표가 안 바뀌면 갱신할 게 없다
   → 신규/삭제/이전만 API 시점에 바로 반영하면 충분 (배치는 복구용으로만)
```

> **핵심 인사이트:** "위치 검색 알고리즘을 뭘 쓸까?"에서 시작한 게 아니라, "사업장 데이터가 얼마나 자주 바뀌는가?"라는 비즈니스 특성에서 출발하여 기술 선택이 자연스럽게 따라왔다.

---

### ADR-1: Redis를 검색 인덱스로 선택한 이유

**출발점:** 사업장 CRUD를 먼저 검토했더니, 사업장 정보는 자주 변하지 않고 하루 1회 배치 갱신으로 충분했다. Read-heavy 특성이 명확한 상황에서 "캐시에 올려두고 읽기만 하면 되겠다"는 결론에 도달했고, 자연스럽게 Redis가 떠올랐다.

**결정:** 검색 인덱스 저장소로 Redis를 사용한다.

**왜 Redis인가:**
* 인메모리 기반으로 단일 노드에서도 10만+ QPS 처리 가능 → 5,800 QPS는 여유롭다.
* 하루 1회만 갱신하면 되므로, 캐시 무효화 전략이 단순하다.
* POI 2억 개 × (ID + 좌표 + 오버헤드) ≈ 약 20GB → 단일 노드로 수용 가능.

**왜 MySQL 단독이 아닌가:**
* MySQL의 공간 인덱스(Spatial Index)로도 가능하지만, 5,800 QPS 이상의 읽기 부하를 감당하려면 다수의 Read Replica가 필요하다.

**왜 Redis 단독이 아닌가:**
* 메모리 기반이라 데이터 영속성이 약하다. 장애 시 유실 가능성.
* 복잡한 조건의 쿼리(카테고리 필터링, 텍스트 검색 등)는 RDB가 유리하다.
* Redis에는 좌표+ID만, 상세 데이터는 MySQL에서 조회하여 메모리 절약.

---

### ADR-2: Geohash 알고리즘 선택

**출발점:** Redis를 검색 인덱스로 쓰기로 한 뒤, "Redis로 위치 기반 검색을 어떻게 하지?"를 조사했다. 마침 Redis가 `GEOADD`, `GEORADIUS` 명령으로 Geohash를 네이티브 지원하고 있었다. 별도로 공간 인덱싱 알고리즘을 구현할 필요 없이 Redis GEO를 그대로 쓰면 된다는 점에서 Geohash가 자연스럽게 선택되었다.

**결정:** 공간 인덱싱 알고리즘으로 Geohash를 사용한다.

**후보군 비교:**

| 알고리즘 | 원리 | 장점 | 단점 |
|---------|------|------|------|
| **Geohash** | 위경도를 Base32 문자열로 변환 | 구현 단순, 접두사 기반 범위 검색 용이, **Redis GEO 내장 지원** | 경계값 문제 (인접 격자 추가 검색 필요) |
| Quadtree | 2D 공간을 재귀적으로 4분할 | 밀도에 따른 적응형 분할, 메모리 효율적 | 트리 구조라 분산 환경에서 공유 어려움, 직접 구현 필요 |
| R-tree | 최소 경계 직사각형(MBR) 기반 트리 | 복잡한 공간 쿼리에 강함, PostGIS 내장 | 구현 복잡도 높음, 삽입/삭제 시 리밸런싱 비용 |
| S2 Geometry | 구면을 Cell로 분할 (Google 개발) | 극지방 왜곡 없음, 정확도 최고 | 라이브러리 의존성, 학습 곡선 높음 |

**선택 근거:**
* Redis GEO가 Geohash를 내부적으로 사용하므로, 별도 인덱스 구현 없이 바로 위치 검색이 가능하다. 이미 Redis를 쓰기로 했으니 가장 자연스러운 선택이었다.
* 접두사 매칭으로 "같은 격자 내 POI"를 O(1)에 가까운 속도로 조회할 수 있다.
* 경계값 문제는 인접 8개 격자를 함께 검색하는 것으로 해결 가능하며, 구현 복잡도가 낮다.

**트레이드오프:**
* Geohash 정밀도 6(약 1.2km×0.6km)은 검색 반경이 작을수록(500m 이하) 불필요한 데이터를 많이 포함한다. 정밀도를 높이면 격자가 작아져 검색해야 할 격자 수가 늘어난다.
* 극지방에서는 Geohash 격자 크기가 왜곡되지만, 실사용 지역(중위도)에서는 문제없다.

> **되돌아보면:** 만약 Redis가 아닌 PostgreSQL을 메인 DB로 골랐다면, PostGIS의 R-tree 기반 공간 인덱스를 썼을 것이다. 저장소 선택이 알고리즘 선택을 결정한 케이스다.

---

### ADR-3: MySQL + Redis 이중 저장소 구조

**결정:** 원본 데이터는 MySQL, 검색 인덱스는 Redis에 분리 저장한다.

ADR-1에서 Redis를 검색 인덱스로 쓰기로 했지만, 원본 데이터의 영속성과 복잡한 쿼리를 위해 MySQL을 병행한다.

**역할 분담:**

| 저장소 | 역할 | 저장 데이터 |
|--------|------|------------|
| MySQL | 원본 데이터, CRUD, 복잡한 쿼리 | 사업장 전체 필드 |
| Redis | 검색 인덱스, 위치 기반 조회 | business_id + 좌표만 |

**"그러면 MySQL이 5,800 QPS를 감당할 수 있는가?"**

Redis에 좌표+ID만 저장하므로, 검색 요청마다 상세 데이터는 결국 MySQL에서 조회해야 한다. 하지만 쿼리 패턴이 완전히 달라지기 때문에 문제없다.

| 항목 | 공간 범위 검색 (MySQL 단독) | PK IN 조회 (현재 구조) |
|------|-------------------------|---------------------|
| 스캔 대상 | 2억 행 중 범위 필터 | 20~50개 PK 직접 접근 |
| 인덱스 | Spatial Index (무거움) | Primary Key (가장 빠름) |
| 연산 | 거리 계산 포함 | 단순 키 매칭 |
| 5,800 QPS | Read Replica 다수 필요 | 단일 노드로도 충분 |

검색의 흐름:
1. Redis `GEORADIUS` → 반경 내 business_id 20~50개 반환 (공간 연산은 Redis가 처리)
2. MySQL `WHERE id IN ('id1', 'id2', ... 'id50')` → PK 인덱스로 직접 접근

2단계의 MySQL 쿼리는 Primary Key 조회이므로 행 수에 관계없이 O(1) per key이고, InnoDB Buffer Pool에 핫 데이터가 캐싱되어 디스크 I/O도 거의 발생하지 않는다. "2억 행에서 범위 검색"과 "50개 PK로 직접 조회"는 부하 수준이 완전히 다르다.

**"그러면 왜 PostgreSQL이 아니라 MySQL인가?"**

공간 연산을 Redis가 전부 처리하므로, PostgreSQL의 가장 큰 강점인 PostGIS가 필요 없어진다. MySQL이 하는 일은 PK 기반 조회와 CRUD뿐이고, 이 용도에서는 MySQL의 단순한 운영이 오히려 유리하다.

| 항목 | MySQL | PostgreSQL |
|------|-------|-----------|
| 공간 인덱스 | 기본 Spatial Index (제한적) | PostGIS (업계 최고 수준) |
| JSON 처리 | JSON 타입 (기본적) | JSONB (인덱싱, 부분 업데이트) |
| 복제/확장 | Read Replica 구성이 단순 | 논리적 복제, 스트리밍 복제 다양 |
| 학습 곡선 | 낮음 | 중간 |
| 클라우드 | AWS Aurora 최적화 | AWS RDS 지원 |

만약 아키텍처가 달랐다면 선택도 달라졌을 것이다:

| 구조 | RDB 선택 |
|------|---------|
| Redis로 공간 검색, DB는 PK 조회만 (현재) | **MySQL** — 단순함으로 충분 |
| DB 단독으로 공간 검색 | **PostgreSQL + PostGIS** — 압도적 우위 |
| 복합 쿼리 (반경 + 카테고리 + 평점 필터) | **PostgreSQL** — PostGIS + 일반 인덱스 결합 우수 |
| JSONB로 가변적 메타데이터 저장 | **PostgreSQL** — JSONB 인덱싱 지원 |

> **일반적인 선택 기준:** "뭘 써야 할지 모르겠다"면 PostgreSQL (기능이 많아 나중에 후회할 일이 적다), "단순 CRUD + 확장"이면 MySQL (운영이 쉽다), "공간 데이터가 핵심"이면 PostgreSQL + PostGIS, "이미 팀에 익숙한 DB가 있다"면 그걸 쓰면 된다.

---

### ADR-4: 데이터 동기화 전략

**원래 계획:** 책에서 제안한 대로 하루 1회 배치 동기화.

**재검토:** Redis에 저장하는 건 business_id + 좌표뿐이다. 사업장 이름, 전화번호, 영업시간 등이 바뀌어도 Redis는 건드릴 필요가 없다. MySQL에서 PK로 조회할 때 최신 데이터가 나오기 때문이다. 그렇다면 Redis 갱신이 필요한 경우는 무엇인가?

| 이벤트 | 빈도 | Redis 작업 |
|--------|------|-----------|
| 신규 사업장 등록 | 하루 수십 건 | `GEOADD` |
| 사업장 삭제 | 매우 드묾 | `ZREM` |
| 위경도 변경 (이전) | 거의 없음 | `ZREM` + `GEOADD` |

하루 수십 건의 쓰기에 배치 파이프라인이나 CDC는 오버엔지니어링이다.

**수정된 결정:** 애플리케이션 레벨에서 즉시 동기화하고, 배치는 복구/보정 용도로만 둔다.

```
일상적인 흐름 (애플리케이션 레벨 동기화):
  POST /v1/businesses       → MySQL INSERT + Redis GEOADD
  DELETE /v1/businesses/:id → MySQL DELETE + Redis ZREM
  PUT /v1/businesses/:id    → MySQL UPDATE + (좌표 변경 시에만) Redis ZREM + GEOADD

예외적인 흐름 (복구용 배치):
  Redis 장애로 데이터 유실 시 → MySQL 전체 데이터로 Redis 인덱스 재구축
  정합성 보정 → 누락된 GEOADD/ZREM 건 일괄 반영
```

**왜 CDC가 아닌가:**
* CDC(Change Data Capture)는 Debezium 등 별도 파이프라인이 필요하며, 운영 복잡도가 크게 증가한다.
* 쓰기가 하루 수십 건 수준이므로 애플리케이션 코드에서 직접 처리하는 것이 가장 단순하다.

**트레이드오프:**
* MySQL INSERT는 성공했는데 Redis GEOADD가 실패하면 정합성이 깨진다. 재시도 로직이나 복구용 배치로 보정한다.
* 책에서 "하루 1회 배치"를 권장한 것은 여러 데이터 소스가 얽힌 대규모 시스템을 전제한 것이며, 단일 서비스에서 쓰기가 극소량인 경우에는 애플리케이션 레벨 동기화가 더 합리적이다.

---

### ADR-5: Read/Write 서비스 분리

**결정:** 검색(Search) 서비스와 관리(Business) 서비스를 독립적으로 배포한다.

**근거:**
* **트래픽 패턴이 극단적으로 다르다.** 검색은 초당 수천 건이지만, 사업장 등록/수정은 하루 수십~수백 건 수준이다.
* **장애 격리:** Business 서비스가 다운되어도 Search 서비스는 Redis 캐시로 정상 동작한다. 검색이 서비스의 핵심 기능이므로 이 가용성이 중요하다.
* **독립적 스케일링:** Search 서비스만 수평 확장하면 된다. Business 서비스는 최소 인스턴스로 운영 가능하다.

**대안: 모놀리식 단일 서비스**
* 구현/배포가 단순하지만, 검색 트래픽 증가 시 CRUD 로직까지 함께 스케일링해야 해서 비효율적이다.

---

### ADR-6: Geohash 정밀도 — 직접 관리하지 않는다

**원래 계획:** 책의 내용을 따라 Geohash 정밀도를 6으로 고정.

**재검토:** API에서 검색 반경(`radius`)을 사용자 입력으로 받는다. 500m일 수도 있고 20km일 수도 있는데, 정밀도를 하나로 고정하면 모든 반경에 최적일 수 없다. 그런데 Redis `GEORADIUS`(또는 최신 `GEOSEARCH`) 명령은 반경을 직접 파라미터로 받아서, 내부적으로 적절한 정밀도를 알아서 처리한다.

```
-- 사용자가 500m를 넣든, 5km를 넣든 Redis가 내부적으로 최적 처리
GEOSEARCH geo:businesses FROMLONLAT 127.0396 37.5012 BYRADIUS 5000 m ASC
```

**수정된 결정:** Geohash 정밀도를 우리가 직접 설정하지 않는다. Redis GEO 명령에 반경을 넘기면 Redis가 알아서 처리한다.

| 접근 방식 | 정밀도 관리 | 해당 경우 |
|----------|-----------|----------|
| **Redis GEORADIUS/GEOSEARCH 사용** | Redis가 내부 처리 (설정 불필요) | **현재 구조** |
| Geohash를 직접 구현 | 반경 → 정밀도 매핑 테이블 필요 | Redis 없이 DB에서 직접 할 때 |

**참고: Geohash 정밀도 테이블 (내부 동작 이해용)**

Redis 내부에서 어떤 일이 일어나는지 이해하기 위한 참고 자료다. 우리가 직접 설정하는 값은 아니다.

| 정밀도 | 격자 크기 | 적합한 검색 반경 |
|--------|----------|----------------|
| 4 | 39.1km × 19.5km | 도시 단위 |
| 5 | 4.9km × 4.9km | 넓은 지역 |
| 6 | 1.2km × 0.6km | 동네 단위 |
| 7 | 153m × 153m | 건물 단위 |

> **학습 노트:** 책에서 정밀도별 격자 크기를 다룬 건 Geohash 알고리즘 자체를 이해시키기 위한 것이다. 만약 Redis 없이 Geohash를 직접 구현한다면 반경에 따라 정밀도를 동적으로 선택하는 매핑 로직이 필요하지만, Redis GEO를 쓰는 한 이 부분은 Redis에 위임된다.
