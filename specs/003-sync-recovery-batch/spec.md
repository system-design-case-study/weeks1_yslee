# Feature Specification: 앱 레벨 동기화 + 복구용 배치

**Feature Branch**: `003-sync-recovery-batch`
**Created**: 2026-02-08
**Status**: Draft
**Input**: User description: "앱 레벨 동기화 + 복구용 배치"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Redis 장애 후 검색 인덱스 복구 (Priority: P1)

시스템 운영 중 Redis 장애가 발생하여 검색 인덱스가 유실되었다. 운영자가 복구용 배치를 실행하여 MySQL의 전체 사업장 데이터를 기반으로 Redis 검색 인덱스를 재구축한다.

**Why this priority**: 검색 서비스가 서비스의 핵심 기능이며, 장애 발생 시 빠른 복구가 가용성 확보의 첫 번째 요건이다. 인덱스 재구축 없이는 검색이 불가능하므로 최우선 순위다.

**Independent Test**: MySQL에 사업장 데이터가 존재하는 상태에서 Redis를 초기화한 뒤 배치를 실행하면, 모든 사업장이 Redis 검색 인덱스에 복구되어 주변 검색이 정상 동작한다.

**Acceptance Scenarios**:

1. **Given** Redis 검색 인덱스가 비어있고 MySQL에 사업장 100건이 존재할 때, **When** 전체 동기화 배치를 실행하면, **Then** 100건 모두 Redis 검색 인덱스에 등록되어 주변 검색으로 조회된다.
2. **Given** Redis에 일부 사업장만 존재(50건)하고 MySQL에 100건이 있을 때, **When** 전체 동기화 배치를 실행하면, **Then** Redis에 100건이 정확히 존재한다(기존 데이터 초기화 후 재구축).
3. **Given** 배치 실행 중 오류가 발생할 때, **When** 일부 데이터만 처리된 상태라면, **Then** 오류 내역이 로그에 기록되고 처리 완료된 건수가 리포트된다.

---

### User Story 2 - 정합성 검증 및 보정 (Priority: P2)

앱 레벨 동기화 중 Redis 동기화 실패로 MySQL과 Redis 사이에 정합성 불일치가 발생할 수 있다. 정합성 검증 배치를 실행하여 누락된 데이터를 찾고 보정한다.

**Why this priority**: 앱 레벨 동기화는 대부분 성공하지만, 네트워크 오류 등으로 간헐적 실패가 가능하다. 정합성 보정은 서비스 품질의 안전망 역할을 한다.

**Independent Test**: MySQL에는 존재하지만 Redis에는 없는 사업장을 의도적으로 만든 뒤, 정합성 검증 배치를 실행하면 누락 건이 Redis에 추가된다.

**Acceptance Scenarios**:

1. **Given** MySQL에 100건이 있고 Redis에 95건만 있을 때, **When** 정합성 검증 배치를 실행하면, **Then** 누락된 5건이 Redis에 추가되고, 처리 결과(추가 5건)가 리포트된다.
2. **Given** Redis에는 존재하지만 MySQL에는 삭제된 사업장 3건이 있을 때, **When** 정합성 검증 배치를 실행하면, **Then** 해당 3건이 Redis에서 제거되고, 처리 결과(제거 3건)가 리포트된다.
3. **Given** MySQL과 Redis 데이터가 완전히 일치할 때, **When** 정합성 검증 배치를 실행하면, **Then** 변경 없이 "정합성 일치" 리포트가 출력된다.

---

### User Story 3 - 앱 레벨 동기화 실패 시 재시도 (Priority: P3)

사업장 등록/삭제/좌표 변경 시 MySQL 작업은 성공했지만 Redis 동기화가 실패한 경우, 시스템이 자동으로 재시도하여 정합성을 유지한다.

**Why this priority**: 실시간 동기화 실패를 즉각 보정하여 정합성 검증 배치에 의존하지 않고도 데이터 일관성을 유지한다. 다만 현재 쓰기가 하루 수십 건 수준이므로 정합성 배치로도 충분히 보정 가능하여 P3로 분류한다.

**Independent Test**: Redis 연결이 일시적으로 불안정한 상태에서 사업장을 등록하면, 첫 시도 실패 후 재시도를 통해 Redis에 반영된다.

**Acceptance Scenarios**:

1. **Given** Redis가 일시적으로 응답하지 않을 때, **When** 사업장 등록 API를 호출하면, **Then** MySQL에는 즉시 저장되고, Redis 동기화는 최대 3회 재시도 후 성공한다.
2. **Given** 3회 재시도 후에도 Redis 동기화가 실패할 때, **When** 재시도가 완료되면, **Then** 실패 로그가 기록되고 MySQL 데이터는 유지된다(검색에서 일시적 누락 가능, 다음 정합성 배치에서 보정).

---

### Edge Cases

- 배치 실행 중 Redis 연결이 끊어지면? → 처리 완료된 건까지 유지하고, 오류 로그 기록 후 중단한다. 재실행 시 전체 재구축한다.
- 배치 실행 중 새로운 사업장이 등록되면? → 전체 동기화 배치는 시작 시점의 데이터를 기준으로 처리한다. 이후 등록된 건은 앱 레벨 동기화로 반영된다.
- 대량 데이터(수백만 건) 처리 시 메모리 문제는? → 페이지 단위로 나누어 처리한다(청크 처리). 한 번에 전체 데이터를 메모리에 로드하지 않는다.
- 전체 동기화와 정합성 검증을 동시에 실행하면? → 동시 실행을 방지한다. 한 번에 하나의 배치만 실행 가능하다.

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: 시스템은 전체 사업장 데이터를 기반으로 검색 인덱스를 재구축하는 전체 동기화 배치를 제공해야 한다.
- **FR-002**: 전체 동기화 배치는 기존 검색 인덱스를 초기화한 후 새로 구축해야 한다.
- **FR-003**: 시스템은 원본 데이터와 검색 인덱스 간 정합성을 검증하고 불일치를 보정하는 정합성 검증 배치를 제공해야 한다.
- **FR-004**: 배치는 대량 데이터를 페이지(청크) 단위로 나누어 처리해야 한다.
- **FR-005**: 배치 실행 결과를 리포트해야 한다(처리 건수, 추가/제거 건수, 오류 건수, 소요 시간).
- **FR-006**: 배치는 동시에 하나만 실행 가능해야 한다(중복 실행 방지).
- **FR-007**: 앱 레벨 동기화(사업장 등록/삭제/좌표 변경 시 검색 인덱스 반영)가 실패하면 최대 3회 재시도해야 한다.
- **FR-008**: 재시도 포함 모든 동기화 실패는 로그에 기록되어야 한다.
- **FR-009**: 배치는 수동 트리거(호출) 방식으로 실행할 수 있어야 한다.
- **FR-010**: 정합성 검증 배치는 원본에 없고 검색 인덱스에만 존재하는 "고아 데이터"를 제거해야 한다.

### Key Entities

- **배치 작업(Batch Job)**: 배치 유형(전체 동기화/정합성 검증), 시작 시각, 종료 시각, 상태(실행 중/완료/실패), 처리 건수, 오류 건수
- **동기화 대상 데이터**: 사업장의 식별자 + 위도 + 경도 (검색 인덱스에 저장되는 최소 데이터)
- **정합성 불일치 항목**: 원본에만 존재(누락), 검색 인덱스에만 존재(고아), 좌표 불일치

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 전체 동기화 배치 실행 후, 원본의 모든 활성 사업장이 검색 인덱스에서 검색 가능해야 한다(100% 일치).
- **SC-002**: 정합성 검증 배치 실행 후, 누락 및 고아 데이터가 0건이어야 한다.
- **SC-003**: 앱 레벨 동기화 재시도를 통해 일시적 장애 시에도 최종 99% 이상의 동기화 성공률을 달성해야 한다.
- **SC-004**: 배치 처리는 1,000건 기준 10초 이내에 완료되어야 한다.
- **SC-005**: 배치 실행 결과(처리 건수, 오류 건수, 소요 시간)가 매 실행마다 리포트되어야 한다.

## Assumptions

- 앱 레벨 동기화는 Phase 2에서 이미 기본 구현이 되어 있다(사업장 CRUD 시 검색 인덱스에 반영). 이번 Phase에서는 실패 재시도를 추가한다.
- 배치는 스케줄러 없이 수동 트리거로만 실행한다. 주기적 자동 실행은 이 기능의 범위 밖이다.
- 쓰기 트래픽이 하루 수십 건 수준이므로 메시지 큐 기반 비동기 동기화는 도입하지 않는다(Simplicity First 원칙).
- 배치 실행 이력은 로그로 관리한다. 별도 배치 이력 테이블은 이 범위에 포함하지 않는다.
